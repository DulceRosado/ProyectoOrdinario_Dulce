import string
import re
tokens = ('INT','FLOAT','STRING','IDENTIFIER','PLUS','MINUS','MUL','DIV','POW','EQ','LPAREN','RPAREN','LSQUARE','RSQUARE','EE','NE','LT','GT','LTE','GTE','COMMA','ARROW','NEWLINE')
reserved = {
    'VAR': 'VAR',
    'AND': 'AND',
    'OR': 'OR',
    'NOT': 'NOT',
    'IF': 'IF',
    'ELIF': 'ELIF',
    'ELSE': 'ELSE',
    'FOR': 'FOR',
    'TO': 'TO',
    'STEP': 'STEP',
    'WHILE': 'WHILE',
    'FUN': 'FUN',
    'THEN': 'THEN',
    'END': 'END',
    'RETURN': 'RETURN',
    'CONTINUE': 'CONTINUE',
    'BREAK': 'BREAK',
}
tokens = tokens + tuple(reserved.values())
class Position:
    def __init__(self, idx, ln, col, fn, ftxt):
        self.idx = idx
        self.ln = ln
        self.col = col
        self.fn = fn
        self.ftxt = ftxt
    def advance(self, current_char=None):
        self.idx += 1
        self.col += 1
        if current_char == '\n':
            self.ln += 1
            self.col = 0
        return self
    def copy(self):
        return Position(self.idx, self.ln, self.col, self.fn, self.ftxt)
class Token:
    def __init__(self, type_, value=None, pos_start=None, pos_end=None):
        self.type = type_
        self.value = value
        if pos_start:
            self.pos_start = pos_start.copy()
            self.pos_end = pos_start.copy()
            self.pos_end.advance()
        if pos_end:
            self.pos_end = pos_end.copy()
    def matches(self, type_, value):
        return self.type == type_ and self.value == value
    def __repr__(self):
        if self.value:
            return f'{self.type}:{self.value}'
        return f'{self.type}'
class LexError(Exception):
    def __init__(self, pos_start, pos_end, details):
        self.pos_start = pos_start
        self.pos_end = pos_end
        self.details = details
        super().__init__(self.details)
    def __str__(self):
        return f"Car√°cter ilegal: {self.details} en la linea {self.pos_start.ln + 1}"
class Lexer:
    def __init__(self, filename='<stdin>', data=''):
        self.filename = filename
        self.data = data
        self.pos = Position(-1, 0, -1, filename, data)
        self.current_char = None
        self.advance()
    def advance(self):
        self.pos.advance(self.current_char)
        self.current_char = self.data[self.pos.idx] if self.pos.idx < len(self.data) else None
    def peek(self, offset=1):
        peek_idx = self.pos.idx + offset
        return self.data[peek_idx] if peek_idx < len(self.data) else None
    t_PLUS = r'\+'
    t_MUL = r'\*'
    t_DIV = r'/'
    t_POW = r'\^'
    t_LPAREN = r'\('
    t_RPAREN = r'\)'
    t_LSQUARE = r'\['
    t_RSQUARE = r'\]'
    t_COMMA = r','
    def skip_comment(self):
        while self.current_char and self.current_char != '\n':
            self.advance()
    def make_number(self):
        num_str = ''
        dot_count = 0
        pos_start = self.pos.copy()
        while self.current_char and (self.current_char.isdigit() or self.current_char == '.'):
            if self.current_char == '.':
                if dot_count == 1:
                    break
                dot_count += 1
            num_str += self.current_char
            self.advance()
        if dot_count == 0:
            return Token('INT', int(num_str), pos_start, self.pos)
        else:
            return Token('FLOAT', float(num_str), pos_start, self.pos)
    def make_identifier(self):
        id_str = ''
        pos_start = self.pos.copy()
        while self.current_char and (self.current_char.isalnum() or self.current_char == '_'):
            id_str += self.current_char
            self.advance()
        tok_type = reserved.get(id_str, 'IDENTIFIER')
        return Token(tok_type, id_str, pos_start, self.pos)
    def make_string(self):
        string_val = ''
        pos_start = self.pos.copy()
        escape_char = False
        self.advance()
        escape_characters = {
            'n': '\n',
            't': '\t',
            'r': '\r',
            '\\': '\\',
            '"': '"'
        }
        while self.current_char and (self.current_char != '"' or escape_char):
            if escape_char:
                string_val += escape_characters.get(self.current_char, self.current_char)
                escape_char = False
            else:
                if self.current_char == '\\':
                    escape_char = True
                else:
                    string_val += self.current_char
            self.advance()
        self.advance() 
        return Token('STRING', string_val, pos_start, self.pos)
    def make_minus_or_arrow(self):
        pos_start = self.pos.copy()
        self.advance()
        if self.current_char == '>':
            self.advance()
            return Token('ARROW', '->', pos_start, self.pos)
        return Token('MINUS', '-', pos_start, self.pos)
    def make_not_equals(self):
        pos_start = self.pos.copy()
        self.advance()
        if self.current_char == '=':
            self.advance()
            return Token('NE', '!=', pos_start, self.pos), None
        return None, LexError(pos_start, self.pos, "'!' (se espera '!=')")
    def make_equals(self):
        pos_start = self.pos.copy()
        self.advance()
        if self.current_char == '=':
            self.advance()
            return Token('EE', '==', pos_start, self.pos)
        return Token('EQ', '=', pos_start, self.pos)
    def make_less_than(self):
        pos_start = self.pos.copy()
        self.advance()
        if self.current_char == '=':
            self.advance()
            return Token('LTE', '<=', pos_start, self.pos)
        return Token('LT', '<', pos_start, self.pos)
    def make_greater_than(self):
        pos_start = self.pos.copy()
        self.advance()
        if self.current_char == '=':
            self.advance()
            return Token('GTE', '>=', pos_start, self.pos)
        return Token('GT', '>', pos_start, self.pos)
    def tokenize(self):
        tokens_list = []
        while self.current_char is not None:
            if self.current_char in ' \t':
                self.advance()
            elif self.current_char == '#':
                self.skip_comment()
            elif self.current_char in ';\n':
                tokens_list.append(Token('NEWLINE', pos_start=self.pos))
                self.advance()
            elif self.current_char.isdigit():
                tokens_list.append(self.make_number())
            elif self.current_char.isalpha() or self.current_char == '_':
                tokens_list.append(self.make_identifier())
            elif self.current_char == '"':
                tokens_list.append(self.make_string())
            elif self.current_char == '+':
                tokens_list.append(Token('PLUS', '+', pos_start=self.pos))
                self.advance()
            elif self.current_char == '-':
                tokens_list.append(self.make_minus_or_arrow())
            elif self.current_char == '*':
                tokens_list.append(Token('MUL', '*', pos_start=self.pos))
                self.advance()
            elif self.current_char == '/':
                tokens_list.append(Token('DIV', '/', pos_start=self.pos))
                self.advance()
            elif self.current_char == '^':
                tokens_list.append(Token('POW', '^', pos_start=self.pos))
                self.advance()
            elif self.current_char == '(':
                tokens_list.append(Token('LPAREN', '(', pos_start=self.pos))
                self.advance()
            elif self.current_char == ')':
                tokens_list.append(Token('RPAREN', ')', pos_start=self.pos))
                self.advance()
            elif self.current_char == '[':
                tokens_list.append(Token('LSQUARE', '[', pos_start=self.pos))
                self.advance()
            elif self.current_char == ']':
                tokens_list.append(Token('RSQUARE', ']', pos_start=self.pos))
                self.advance()
            elif self.current_char == '!':
                token, error = self.make_not_equals()
                if error:
                    return [], error
                tokens_list.append(token)
            elif self.current_char == '=':
                tokens_list.append(self.make_equals())
            elif self.current_char == '<':
                tokens_list.append(self.make_less_than())
            elif self.current_char == '>':
                tokens_list.append(self.make_greater_than())
            elif self.current_char == ',':
                tokens_list.append(Token('COMMA', ',', pos_start=self.pos))
                self.advance()
            else:
                pos_start = self.pos.copy()
                char = self.current_char
                self.advance()
                return [], LexError(pos_start, self.pos, f"'{char}'")
        tokens_list.append(Token('EOF', pos_start=self.pos))
        return tokens_list, None
